Service impl



package com.recruitment.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.recruitment.exception.CandidateAlreadyExistsException;
import com.recruitment.model.Candidate;

public class RecruitmentServiceImpl implements IRecruitmentService {

	private static List<Candidate> candidateList=new ArrayList<Candidate>();
	
	private static Logger logger = LoggerFactory.getLogger(IRecruitmentService.class);
	
	/*
	 * This method should add the candidate object to the candidateList, before adding it shoulkd check
	 * whether the email id of the candidate is already available, if available throw an exception
	 * else add the candidate object into the list
	 */
	public Candidate registerCandidate(Candidate candidate) throws CandidateAlreadyExistsException {
		// TODO Auto-generated method stub
		if(candidateList.contains(candidate)) {
			logger.error("Candidate already exists with us");
			throw new CandidateAlreadyExistsException();
		    
		}
		else {
	    candidateList.add(candidate);
	    logger.info("Candidate with id"+candidate.getCandidateId()+"registered successfully");
		return candidate;
		}
	}

	/*
	 * This method should return the Map as position applied for as a key and list of candidates who applied for that position as value.
	 */
	public Map<String, List<Candidate>> viewCandidateBasedonPosition() {
		// TODO Auto-generated method stub

		Map<String,List<Candidate>> result = new HashMap<>();
		for(Candidate c : candidateList) {
		

			if (!result.containsKey(c.getPositionAppliedFor())) {

			            result.put(c.getPositionAppliedFor(), new ArrayList<Candidate>());

			        }

			        result.get(c.getPositionAppliedFor()).add(c);

			    }
			
		logger.info("View candidate based on position is successful");
		return result;
	}

	/*
	 * This method should accept the years of experience as input and it should  
	 *  iterate the candidateList and return the list of candidates who have that experience.
	 */
	public List<Candidate> filterCandidate(int yearsOfExperience) {
		// TODO Auto-generated method stub
		List<Candidate> filteredList = new ArrayList<>();
		filteredList = candidateList.stream().filter(c->c.getYearsOfExperience()==yearsOfExperience).collect(Collectors.toList());
		logger.info("View candidate based on the experience is successfully done");
		return filteredList;
	}

	
	/*
	 * This method should remove the candidate based on the status. 
	 * If the status is recruited then remove all those candidates.
	 * This method should return the number of candidates removed.
	 */
	public int removeCandidate() {
		// TODO Auto-generated method stub
		int count = 0;
		List<Candidate> copy = new ArrayList<>();
		copy.addAll(candidateList);
		for(Candidate c: copy) {
			if(c.getStatus().equals("recruited")) {
				candidateList.remove(c);
				count++;
			}
		}
		logger.info("<<xxx>> candidate recruited via Employ Me");
		return count;
	}

	
	
public static List<Candidate> getCandidateList() {
		return candidateList;
	}

	public static void setCandidateList(List<Candidate> candidateList) {
		RecruitmentServiceImpl.candidateList = candidateList;
	}

	
}

/////CONTROLLER



package com.recruitment.controller;

import java.util.List;
import java.util.Map;

import javax.validation.Valid;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.recruitment.exception.CandidateAlreadyExistsException;
import com.recruitment.model.Candidate;
import com.recruitment.service.IRecruitmentService;
import com.recruitment.validation.RecruitmentValidator;

@RestController
//@RequestMapping("/recruitmentapp")
public class RecruitmentController {
	
	@Autowired
	IRecruitmentService recruitmentService;
	
	@Autowired
	RecruitmentValidator recruitmentValidator;
	
	@PostMapping("/register")
	public Candidate registerCandidate(@RequestBody @Valid Candidate candidate) throws CandidateAlreadyExistsException {
		
		return recruitmentService.registerCandidate(candidate);

	}
	
	@GetMapping("/view")
	public Map<String,List<Candidate>> viewCandidateBasedonPosition(){
		return recruitmentService.viewCandidateBasedonPosition();
		
	}
	
	@GetMapping("/filter/{yearsOfExperience}")
	public List<Candidate> filterCandidate(@PathVariable int yearsOfExperience){
		return recruitmentService.filterCandidate(yearsOfExperience);
		
	}
	@DeleteMapping("/remove")
    public int removeCandidate() {
		return recruitmentService.removeCandidate();
	}

}



//////
package com.recruitment.exception;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;




public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {


	
	public final ResponseEntity<Object> handleAllExceptions(Exception ex, WebRequest request) {

		return null;
	}


	public final ResponseEntity<ExceptionResponse> handleNotFoundException(CandidateAlreadyExistsException ex, WebRequest request) {
		return null;
	}

	@Override
	protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {
		
		return null;
	}


////////

package com.recruitment.exception;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;




public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {


	
	public final ResponseEntity<Object> handleAllExceptions(Exception ex, WebRequest request) {

		return null;
	}


	public final ResponseEntity<ExceptionResponse> handleNotFoundException(CandidateAlreadyExistsException ex, WebRequest request) {
		return null;
	}

	@Override
	protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {
		
		return null;
	}



//////////////////////

package com.recruitment.exception;


public class CandidateAlreadyExistsException extends Exception{

	
	

}



////////////////////////validation

package com.recruitment.validation;

import org.springframework.validation.Errors;
import org.springframework.validation.beanvalidation.CustomValidatorBean;

import com.recruitment.model.Candidate;


public class RecruitmentValidator extends CustomValidatorBean {

	@Override
    public boolean supports(Class<?> clazz) {
    return Candidate.class.isAssignableFrom(clazz);
    }

    @Override
    public void validate(Object target, Errors errors) {
          super.validate(target, errors);
    
    	  
        } 
}


/////////////////////model
package com.recruitment.model;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class Candidate {
	
	
	private String candidateId	;
	private String candidateName;	
	private String mobileNumber	;
	private String emailId	;
	private String positionAppliedFor	;
	private Integer yearsOfExperience	;
	private double expectedSalary	;
	
	private String Status	;


	





	public Candidate() {
		
	}

	public Candidate(String candidateId, String candidateName, String mobileNumber, String emailId,
			String positionAppliedFor, Integer yearsOfExperience, double expectedSalary, String status) {
		super();
		this.candidateId = candidateId;
		this.candidateName = candidateName;
		this.mobileNumber = mobileNumber;
		this.emailId = emailId;
		this.positionAppliedFor = positionAppliedFor;
		this.yearsOfExperience = yearsOfExperience;
		this.expectedSalary = expectedSalary;
		Status = status;
	}

}



//////////Agency app.properties

server.port=9090
logging.config=src/main/resources/logger.xml

spring.application.name=recruitmentapp
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka



RECRUITMENT APPLICATION
/////////////Recruitment Application.java

package com.recruitment.app;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableCircuitBreaker
@EnableDiscoveryClient
public class RecruitmentApplication {

	public static void main(String[] args) {
		SpringApplication.run(RecruitmentApplication.class, args);
	}

}


///////////applicationcontroller.java

package com.recruitment.controller;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import com.recruitment.proxy.ServiceProxy;


@RestController
public class ApplicationController {
    
	@Autowired
	ServiceProxy serviceProxy;
	
	@GetMapping("/greet")
	public String retreiveInfo( ) {
		
		return serviceProxy.greeting();
		
	}
	
	public String fallback(Exception e) {
		return "Sorry Service is unavailable";
	}
	
}



////////////////////serviceproxy

package com.recruitment.proxy;


import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@FeignClient(url="http://localhost:8091")
@RibbonClient()
@EnableCircuitBreaker
public interface ServiceProxy {
	    @GetMapping(value="/welcome")
	   public String greeting();
}

////////////////application.properties



GREETING
//////////////////app.properties

server.port=8091
spring.application.name = RestaurantGreeting



RECRUITMENT REGISTRY

//////////////////recruitmentregapp.java

package com.recruitment.app;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class RecruitmentRegistryApplication {

	public static void main(String[] args) {
		SpringApplication.run(RecruitmentRegistryApplication.class, args);
	}

}



/////////////app.properties

server.port = 8761

eureka.instance.hostname=localhost

eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false



ROUTER

/////////////recruitmentrouter.java
package com.recruitment.app;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;

@SpringBootApplication
@EnableZuulProxy
@EnableDiscoveryClient
@EnableEurekaClient
public class RecruitmentRouterApplication {

	public static void main(String[] args) {
		SpringApplication.run(RecruitmentRouterApplication.class, args);
	}

}


//////////////////////application.properties
server.port=8777

spring.application.name=gateway-service


# Eureka Client Configuration

eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka


# Zuul Proxy Configuration

zuul.routes.recruitmentapp.path=/register/**

zuul.routes.recruitmentapp.url=http://localhost:9090


zuul.routes.view.path=/view/**

zuul.routes.recruitmentapp.url=http://localhost:9090


zuul.routes.filter.path=/filter/**

zuul.routes.filter.service-id=recruitmentapp


zuul.routes.remove.path=/remove/**

zuul.routes.recruitmentapp.url=http://localhost:9090


